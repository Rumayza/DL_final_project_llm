reinforcement learning rl is an interdisciplinary area of machine learning and optimal control concerned with how an intelligent agent should take actions in a dynamic environment in order to maximize a reward signal reinforcement learning is one of the three basic machine learning paradigms alongside supervised learning and unsupervised learning qlearning at its simplest stores data in tables this approach becomes infeasible as the number of statesactions increases eg if the state space or action space were continuous as the probability of the agent visiting a particular state and performing a particular action diminishes reinforcement learning differs from supervised learning in not needing labelled inputoutput pairs to be presented and in not needing suboptimal actions to be explicitly corrected instead the focus is on finding a balance between exploration of uncharted territory and exploitation of current knowledge with the goal of maximizing the cumulative reward the feedback of which might be incomplete or delayed the search for this balance is known as the explorationexploitation dilemma the environment is typically stated in the form of a markov decision process mdp as many reinforcement learning algorithms use dynamic programming techniques the main difference between classical dynamic programming methods and reinforcement learning algorithms is that the latter do not assume knowledge of an exact mathematical model of the markov decision process and they target large mdps where exact methods become infeasible introduction due to its generality reinforcement learning is studied in many disciplines such as game theory control theory operations research information theory simulationbased optimization multiagent systems swarm intelligence and statistics in the operations research and control literature rl is called approximate dynamic programming or neurodynamic programming the problems of interest in rl have also been studied in the theory of optimal control which is concerned mostly with the existence and characterization of optimal solutions and algorithms for their exact computation and less with learning or approximation particularly in the absence of a mathematical model of the environment basic reinforcement learning is modeled as a markov decision process a set of environment and agent states the state space s displaystyle mathcal s a set of actions the action space a displaystyle mathcal a of the agent p a s s pr s t 1 s s t s a t a displaystyle passprst1smid stsata the transition probability at time t displaystyle t from state s displaystyle s to state s displaystyle s under action a displaystyle a r a s s displaystyle rass the immediate reward after transition from s displaystyle s to s displaystyle s under action a displaystyle a the purpose of reinforcement learning is for the agent to learn an optimal or nearoptimal policy that maximizes the reward function or other userprovided reinforcement signal that accumulates from immediate rewards this is similar to processes that appear to occur in animal psychology for example biological brains are hardwired to interpret signals such as pain and hunger as negative reinforcements and interpret pleasure and food intake as positive reinforcements in some circumstances animals learn to adopt behaviors that optimize these rewards this suggests that animals are capable of reinforcement learning a basic reinforcement learning agent interacts with its environment in discrete time steps at each time step t the agent receives the current state s t displaystyle st and reward r t displaystyle rt it then chooses an action a t displaystyle at from the set of available actions which is subsequently sent to the environment the environment moves to a new state s t 1 displaystyle st1 and the reward r t 1 displaystyle rt1 associated with the transition s t a t s t 1 displaystyle statst1 is determined the goal of a reinforcement learning agent is to learn a policy s a 0 1 displaystyle pi mathcal stimes mathcal arightarrow 01 s a pr a t a s t s displaystyle pi sapratamid sts that maximizes the expected cumulative reward formulating the problem as a markov decision process assumes the agent directly observes the current environmental state in this case the problem is said to have full observability if the agent only has access to a subset of states or if the observed states are corrupted by noise the agent is said to have partial observability and formally the problem must be formulated as a partially observable markov decision process in both cases the set of actions available to the agent can be restricted for example the state of an account balance could be restricted to be positive if the current value of the state is 3 and the state transition attempts to reduce the value by 4 the transition will not be allowed when the agents performance is compared to that of an agent that acts optimally the difference in performance yields the notion of regret in order to act near optimally the agent must reason about longterm consequences of its actions ie maximize future rewards although the immediate reward associated with this might be negative thus reinforcement learning is particularly wellsuited to problems that include a longterm versus shortterm reward tradeoff it has been applied successfully to various problems including energy storage robot control photovoltaic generators backgammon checkers go alphago and autonomous driving systems two elements make reinforcement learning powerful the use of samples to optimize performance and the use of function approximation to deal with large environments thanks to these two key components rl can be used in large environments in the following situations a model of the environment is known but an analytic solution is not available only a simulation model of the environment is given the subject of simulationbased optimization the only way to collect information about the environment is to interact with it the first two of these problems could be considered planning problems since some form of model is available while the last one could be considered to be a genuine learning problem however reinforcement learning converts both planning problems to machine learning problems exploration the exploration vs exploitation tradeoff has been most thoroughly studied through the multiarmed bandit problem and for finite state space markov decision processes in burnetas and katehakis 1997 reinforcement learning requires clever exploration mechanisms randomly selecting actions without reference to an estimated probability distribution shows poor performance the case of small finite markov decision processes is relatively well understood however due to the lack of algorithms that scale well with the number of states or scale to problems with infinite state spaces simple exploration methods are the most practical one such method is displaystyle varepsilon greedy where 0 1 displaystyle 0varepsilon 1 is a parameter controlling the amount of exploration vs exploitation with probability 1 displaystyle 1varepsilon exploitation is chosen and the agent chooses the action that it believes has the best longterm effect ties between actions are broken uniformly at random alternatively with probability displaystyle varepsilon exploration is chosen and the action is chosen uniformly at random displaystyle varepsilon is usually a fixed parameter but can be adjusted either according to a schedule making the agent explore progressively less or adaptively based on heuristics algorithms for control learning even if the issue of exploration is disregarded and even if the state was observable assumed hereafter the problem remains to use past experience to find out which actions lead to higher cumulative rewards criterion of optimality policy the agents action selection is modeled as a map called policy a s 0 1 displaystyle pi mathcal atimes mathcal srightarrow 01 a s pr a t a s t s displaystyle pi aspratamid sts the policy map gives the probability of taking action a displaystyle a when in state s displaystyle s 61 there are also deterministic policies statevalue function the statevalue function v s displaystyle vpi s is defined as expected discounted return starting with state s displaystyle s ie s 0 s displaystyle s0s and successively following policy displaystyle pi hence roughly speaking the value function estimates how good it is to be in a given state 60 v s e g s 0 s e t 0 t r t 1 s 0 s displaystyle vpi soperatorname mathbb e gmid s0soperatorname mathbb e leftsum t0infty gamma trt1mid s0sright where the random variable g displaystyle g denotes the discounted return and is defined as the sum of future discounted rewards g t 0 t r t 1 r 1 r 2 2 r 3 displaystyle gsum t0infty gamma trt1r1gamma r2gamma 2r3dots where r t 1 displaystyle rt1 is the reward for transitioning from state s t displaystyle st to s t 1 displaystyle st1 0 1 displaystyle 0leq gamma 1 is the discount rate displaystyle gamma is less than 1 so rewards in the distant future are weighted less than rewards in the immediate future the algorithm must find a policy with maximum expected discounted return from the theory of markov decision processes it is known that without loss of generality the search can be restricted to the set of socalled stationary policies a policy is stationary if the actiondistribution returned by it depends only on the last state visited from the observation agents history the search can be further restricted to deterministic stationary policies a deterministic stationary policy deterministically selects actions based on the current state since any such policy can be identified with a mapping from the set of states to the set of actions these policies can be identified with such mappings with no loss of generality brute force the brute force approach entails two steps for each possible policy sample returns while following it choose the policy with the largest expected discounted return one problem with this is that the number of policies can be large or even infinite another is that the variance of the returns may be large which requires many samples to accurately estimate the discounted return of each policy these problems can be ameliorated if we assume some structure and allow samples generated from one policy to influence the estimates made for others the two main approaches for achieving this are value function estimation and direct policy search value function value function approaches attempt to find a policy that maximizes the discounted return by maintaining a set of estimates of expected discounted returns e g displaystyle operatorname mathbb e g for some policy usually either the current onpolicy or the optimal offpolicy one these methods rely on the theory of markov decision processes where optimality is defined in a sense stronger than the one above a policy is optimal if it achieves the bestexpected discounted return from any initial state ie initial distributions play no role in this definition again an optimal policy can always be found among stationary policies to define optimality in a formal manner define the statevalue of a policy displaystyle pi by v s e g s displaystyle vpi soperatorname mathbb e gmid spi where g displaystyle g stands for the discounted return associated with following displaystyle pi from the initial state s displaystyle s defining v s displaystyle vs as the maximum possible statevalue of v s displaystyle vpi s where displaystyle pi is allowed to change v s max v s displaystyle vsmax pi vpi s a policy that achieves these optimal statevalues in each state is called optimal clearly a policy that is optimal in this sense is also optimal in the sense that it maximizes the expected discounted return since v s max e g s displaystyle vsmax pi mathbb e gmid spi where s displaystyle s is a state randomly sampled from the distribution displaystyle mu of initial states so s pr s 0 s displaystyle mu sprs0s although statevalues suffice to define optimality it is useful to define actionvalues given a state s displaystyle s an action a displaystyle a and a policy displaystyle pi the actionvalue of the pair s a displaystyle sa under displaystyle pi is defined by q s a e g s a displaystyle qpi saoperatorname mathbb e gmid sapi where g displaystyle g now stands for the random discounted return associated with first taking action a displaystyle a in state s displaystyle s and following displaystyle pi thereafter the theory of markov decision processes states that if displaystyle pi is an optimal policy we act optimally take the optimal action by choosing the action from q s displaystyle qpi scdot with the highest actionvalue at each state s displaystyle s the actionvalue function of such an optimal policy q displaystyle qpi is called the optimal actionvalue function and is commonly denoted by q displaystyle q in summary the knowledge of the optimal actionvalue function alone suffices to know how to act optimally assuming full knowledge of the markov decision process the two basic approaches to compute the optimal actionvalue function are value iteration and policy iteration both algorithms compute a sequence of functions q k displaystyle qk k 0 1 2 displaystyle k012ldots that converge to q displaystyle q computing these functions involves computing expectations over the whole statespace which is impractical for all but the smallest finite markov decision processes in reinforcement learning methods expectations are approximated by averaging over samples and using function approximation techniques to cope with the need to represent value functions over large stateaction spaces monte carlo methods monte carlo methods are used to solve reinforcement learning problems by averaging sample returns unlike methods that require full knowledge of the environments dynamics monte carlo methods rely solely on actual or simulated experiencesequences of states actions and rewards obtained from interaction with an environment this makes them applicable in situations where the complete dynamics are unknown learning from actual experience does not require prior knowledge of the environment and can still lead to optimal behavior when using simulated experience only a model capable of generating sample transitions is required rather than a full specification of transition probabilities which is necessary for dynamic programming methods monte carlo methods apply to episodic tasks where experience is divided into episodes that eventually terminate policy and value function updates occur only after the completion of an episode making these methods incremental on an episodebyepisode basis though not on a stepbystep online basis the term monte carlo generally refers to any method involving random sampling however in this context it specifically refers to methods that compute averages from complete returns rather than partial returns these methods function similarly to the bandit algorithms in which returns are averaged for each stateaction pair the key difference is that actions taken in one state affect the returns of subsequent states within the same episode making the problem nonstationary to address this nonstationarity monte carlo methods use the framework of general policy iteration gpi while dynamic programming computes value functions using full knowledge of the markov decision process mdp monte carlo methods learn these functions through sample returns the value functions and policies interact similarly to dynamic programming to achieve optimality first addressing the prediction problem and then extending to policy improvement and control all based on sampled experience temporal difference methods the first problem is corrected by allowing the procedure to change the policy at some or all states before the values settle this too may be problematic as it might prevent convergence most current algorithms do this giving rise to the class of generalized policy iteration algorithms many actorcritic methods belong to this category the second issue can be corrected by allowing trajectories to contribute to any stateaction pair in them this may also help to some extent with the third problem although a better solution when returns have high variance is suttons temporal difference td methods that are based on the recursive bellman equation the computation in td methods can be incremental when after each transition the memory is changed and the transition is thrown away or batch when the transitions are batched and the estimates are computed once based on the batch batch methods such as the leastsquares temporal difference method may use the information in the samples better while incremental methods are the only choice when batch methods are infeasible due to their high computational or memory complexity some methods try to combine the two approaches methods based on temporal differences also overcome the fourth issue another problem specific to td comes from their reliance on the recursive bellman equation most td methods have a socalled displaystyle lambda parameter 0 1 displaystyle 0leq lambda leq 1 that can continuously interpolate between monte carlo methods that do not rely on the bellman equations and the basic td methods that rely entirely on the bellman equations this can be effective in palliating this issue function approximation methods in order to address the fifth issue function approximation methods are used linear function approximation starts with a mapping displaystyle phi that assigns a finitedimensional vector to each stateaction pair then the action values of a stateaction pair s a displaystyle sa are obtained by linearly combining the components of s a displaystyle phi sa with some weights displaystyle theta q s a i 1 d i i s a displaystyle qsasum i1dtheta iphi isa the algorithms then adjust the weights instead of adjusting the values associated with the individual stateaction pairs methods based on ideas from nonparametric statistics which can be seen to construct their own features have been explored value iteration can also be used as a starting point giving rise to the qlearning algorithm and its many variants including deep qlearning methods when a neural network is used to represent q with various applications in stochastic search problems the problem with using actionvalues is that they may need highly precise estimates of the competing action values that can be hard to obtain when the returns are noisy though this problem is mitigated to some extent by temporal difference methods using the socalled compatible function approximation method compromises generality and efficiency direct policy search an alternative method is to search directly in some subset of the policy space in which case the problem becomes a case of stochastic optimization the two approaches available are gradientbased and gradientfree methods gradientbased methods policy gradient methods start with a mapping from a finitedimensional parameter space to the space of policies given the parameter vector displaystyle theta let displaystyle pi theta denote the policy associated to displaystyle theta defining the performance function by displaystyle rho theta rho pi theta under mild conditions this function will be differentiable as a function of the parameter vector displaystyle theta if the gradient of displaystyle rho was known one could use gradient ascent since an analytic expression for the gradient is not available only a noisy estimate is available such an estimate can be constructed in many ways giving rise to algorithms such as williams reinforce method which is known as the likelihood ratio method in the simulationbased optimization literature a large class of methods avoids relying on gradient information these include simulated annealing crossentropy search or methods of evolutionary computation many gradientfree methods can achieve in theory and in the limit a global optimum policy search methods may converge slowly given noisy data for example this happens in episodic problems when the trajectories are long and the variance of the returns is large valuefunction based methods that rely on temporal differences might help in this case in recent years actorcritic methods have been proposed and performed well on various problems policy search methods have been used in the robotics context many policy search methods may get stuck in local optima as they are based on local search modelbased algorithms finally all of the above methods can be combined with algorithms that first learn a model of the markov decision process the probability of each next state given an action taken from an existing state for instance the dyna algorithm learns a model from experience and uses that to provide more modelled transitions for a value function in addition to the real transitions such methods can sometimes be extended to use of nonparametric models such as when the transitions are simply stored and replayed to the learning algorithm modelbased methods can be more computationally intensive than modelfree approaches and their utility can be limited by the extent to which the markov decision process can be learnt there are other ways to use models than to update a value function for instance in model predictive control the model is used to update the behavior directly theory both the asymptotic and finitesample behaviors of most algorithms are well understood algorithms with provably good online performance addressing the exploration issue are known efficient exploration of markov decision processes is given in burnetas and katehakis 1997 finitetime performance bounds have also appeared for many algorithms but these bounds are expected to be rather loose and thus more work is needed to better understand the relative advantages and limitations for incremental algorithms asymptotic convergence issues have been settled temporaldifferencebased algorithms converge under a wider set of conditions than was previously possible for example when used with arbitrary smooth function approximation research research topics include actorcritic architecture actorcriticscenery architecture adaptive methods that work with fewer or no parameters under a large number of conditions bug detection in software projects continuous learning combinations with logicbased frameworks exploration in large markov decision processes human feedback interaction between implicit and explicit learning in skill acquisition intrinsic motivation which differentiates informationseeking curiositytype behaviours from taskdependent goaldirected behaviours largescale empirical evaluations large or continuous action spaces modular and hierarchical reinforcement learning multiagentdistributed reinforcement learning is a topic of interest applications are expanding occupantcentric control optimization of computing resources partial information eg using predictive state representation reward function based on maximising novel information samplebased planning eg based on monte carlo tree search securities trading transfer learning td learning modeling dopaminebased learning in the brain dopaminergic projections from the substantia nigra to the basal ganglia function are the prediction error valuefunction and policy search methods comparison of key algorithms associative reinforcement learning associative reinforcement learning tasks combine facets of stochastic learning automata tasks and supervised learning pattern classification tasks in associative reinforcement learning tasks the learning system interacts in a closed loop with its environment deep reinforcement learning this approach extends reinforcement learning by using a deep neural network and without explicitly designing the state space the work on learning atari games by google deepmind increased attention to deep reinforcement learning or endtoend reinforcement learning adversarial deep reinforcement learning adversarial deep reinforcement learning is an active area of research in reinforcement learning focusing on vulnerabilities of learned policies in this research area some studies initially showed that reinforcement learning policies are susceptible to imperceptible adversarial manipulations while some methods have been proposed to overcome these susceptibilities in the most recent studies it has been shown that these proposed solutions are far from providing an accurate representation of current vulnerabilities of deep reinforcement learning policies fuzzy reinforcement learning by introducing fuzzy inference in reinforcement learning approximating the stateaction value function with fuzzy rules in continuous space becomes possible the if then form of fuzzy rules make this approach suitable for expressing the results in a form close to natural language extending frl with fuzzy rule interpolation allows the use of reduced size sparse fuzzy rulebases to emphasize cardinal rules most important stateaction values inverse reinforcement learning in inverse reinforcement learning irl no reward function is given instead the reward function is inferred given an observed behavior from an expert the idea is to mimic observed behavior which is often optimal or close to optimal one popular irl paradigm is named maximum entropy inverse reinforcement learning maxent irl maxent irl estimates the parameters of a linear model of the reward function by maximizing the entropy of the probability distribution of observed trajectories subject to constraints related to matching expected feature counts recently it has been shown that maxent irl is a particular case of a more general framework named random utility inverse reinforcement learning ruirl ruirl is based on random utility theory and markov decision processes while prior irl approaches assume that the apparent random behavior of an observed agent is due to it following a random policy ruirl assumes that the observed agent follows a deterministic policy but randomness in observed behavior is due to the fact that an observer only has partial access to the features the observed agent uses in decision making the utility function is modeled as a random variable to account for the ignorance of the observer regarding the features the observed agent actually considers in its utility function safe reinforcement learning safe reinforcement learning srl can be defined as the process of learning policies that maximize the expectation of the return in problems in which it is important to ensure reasonable system performance andor respect safety constraints during the learning andor deployment processes an alternative approach is riskaverse reinforcement learning where instead of the expected return a riskmeasure of the return is optimized such as the conditional value at risk cvar in addition to mitigating risk the cvar objective increases robustness to model uncertainties however cvar optimization in riskaverse rl requires special care to prevent gradient bias and blindness to success selfreinforcement learning selfreinforcement learning or self learning is a learning paradigm which does not use the concept of immediate reward rass after transition from s to s with action a it does not use an external reinforcement it only uses the agent internal selfreinforcement the internal selfreinforcement is provided by mechanism of feelings and emotions in the learning process emotions are backpropagated by a mechanism of secondary reinforcement the learning equation does not include the immediate reward it only includes the state evaluation the selfreinforcement algorithm updates a memory matrix w was such that in each iteration executes the following machine learning routine 1 in situation s perform action a 2 receive a consequence situation s 3 compute state evaluation vs of how good is to be in the consequence situation s 4 update crossbar memory was was vs initial conditions of the memory are received as input from the genetic environment it is a system with only one input situation and only one output action or behavior self reinforcement self learning was introduced in 1982 along with a neural network capable of selfreinforcement learning named crossbar adaptive array caa the caa computes in a crossbar fashion both decisions about actions and emotions feelings about consequence states the system is driven by the interaction between cognition and emotion statistical comparison of reinforcement learning algorithms efficient comparison of rl algorithms is essential for research deployment and monitoring of rl systems to compare different algorithms on a given environment an agent can be trained for each algorithm since the performance is sensitive to implementation details all algorithms should be implemented as closely as possible to each other after the training is finished the agents can be run on a sample of test episodes and their scores returns can be compared since episodes are typically assumed to be iid standard statistical tools can be used for hypothesis testing such as ttest and permutation test this requires to accumulate all the rewards within an episode into a single number the episodic return however this causes a loss of information as different timesteps are averaged together possibly with different levels of noise whenever the noise level varies across the episode the statistical power can be improved significantly by weighting the rewards according to their estimated noise see also references further reading annaswamy anuradha m 3 may 2023 adaptive control and intersections with reinforcement learning annual review of control robotics and autonomous systems 6 1 6593 doi101146annurevcontrol062922090153 issn 25735144 s2cid 255702873 auer peter jaksch thomas ortner ronald 2010 nearoptimal regret bounds for reinforcement learning journal of machine learning research 11 15631600 bertsekas dimitri p 2023 2019 reinforcement learning and optimal control 1st ed athena scientific isbn 9781886529397 busoniu lucian babuska robert de schutter bart ernst damien 2010 reinforcement learning and dynamic programming using function approximators taylor francis crc press isbn 9781439821084 franoislavet vincent henderson peter islam riashat bellemare marc g pineau joelle 2018 an introduction to deep reinforcement learning foundations and trends in machine learning 11 34 219354 arxiv181112560 bibcode2018arxiv181112560f doi1015612200000071 s2cid 54434537 li shengbo eben 2023 reinforcement learning for sequential decision and optimal control 1st ed springer verlag singapore doi1010079789811977848 isbn 9789811977831 powell warren 2011 approximate dynamic programming solving the curses of dimensionality wileyinterscience archived from the original on 20160731 retrieved 20100908 sutton richard s 1988 learning to predict by the method of temporal differences machine learning 3 944 doi101007bf00115009 sutton richard s barto andrew g 2018 1998 reinforcement learning an introduction 2nd ed mit press isbn 9780262039246 szita istvan szepesvari csaba 2010 modelbased reinforcement learning with nearly tight exploration complexity bounds pdf icml 2010 omnipress pp 10311038 archived from the original pdf on 20100714 external links dissecting reinforcement learning series of blog post on reinforcement learning with python code a long peek into reinforcement learning